from functools import partial
from starcluster import clustersetup
from starcluster.logger import log
from starcluster.exception import BaseException


class DatacraticPrePlugin(clustersetup.DefaultClusterSetup):

    def __init__(self, tag_billcode, security_groups=[],
                 starbase_client_group_id=None):
        self.tag_billcode = tag_billcode
        self.starbase_client_group_id = starbase_client_group_id
        if type(security_groups) is list:
            self.security_groups = security_groups
        else:
            self.security_groups = \
                [sg.strip() for sg in security_groups.split(",")]

    def run(self, nodes, master, user, user_shell, volumes):
        master.add_tag("billcode", self.tag_billcode)
        self.update_cluster_security_group(master)
        self.update_instance_security_groups(master)

    def on_add_node(self, node, nodes, master, user, user_shell, volumes):

        node.add_tag("billcode", self.tag_billcode)
        self.update_instance_security_groups(node)

        # Run the /home/useradd.sh script if it exists
        # that script is generated by saltstack and contains
        # the commands used to setup users on the worker nodes
        node.ssh.execute("test -f /home/useradd.sh && /home/useradd.sh")

        log.info("Creating /mnt/s3cache")
        msg = node.ssh.execute("file /mnt/s3cache", ignore_exit_status=True)
        if msg[0].find("ERROR") == -1:
                log.warning("/mnt/s3Cache already exists")
        else:
                node.ssh.execute("install -d -m 1777 /mnt/s3cache")

    def on_remove_node(self, node, nodes, master, user, user_shell, volumes):
        pass

    def clean_cluster(self, nodes, master, user, user_shell, volumes):
        pass

    def recover(self, nodes, master, user, user_shell, volumes):
        pass

    def update_cluster_security_group(self, master):
        """
        Update the cluster security group permissions
        """
        for group in master.instance.groups:
            if group.name[:4] == "@sc-":
                groups = master.ec2.conn.get_all_security_groups(
                    group_ids=[group.id])
                if not groups:
                    raise BaseException("Failed to fetch the group associated "
                                        "to id {}".format(group.id))
                group = groups[0]
                break
        else:
            raise BaseException("Failed to find the cluster security group")

        # Erase all rules and create them anew
        # copy the list because it seems to be updated asynchronously
        group_rules = list(group.rules)
        for ip_permission in group_rules:
            revoke = partial(group.revoke,
                             ip_protocol=ip_permission.ip_protocol,
                             from_port=ip_permission.from_port,
                             to_port=ip_permission.to_port)
            if ip_permission.grants:
                grant = ip_permission.grants[0]
                if grant.group_id:
                    revoke(src_group=grant)
                    continue
                elif grant.cidr_ip:
                    revoke(cidr_ip=grant)
                    continue
            log.warning("Group rule removal probably failed")
            revoke()

        # Create the rules we want
        # All within this cluster
        group.authorize(ip_protocol='-1',
                        from_port='-1',
                        to_port='-1',
                        src_group=group)

        if self.starbase_client_group_id:
            # StarBase Client group
            grp_lst = master.ec2.conn.get_all_security_groups(
                group_ids=[self.starbase_client_group_id])
            if not grp_lst:
                raise BaseException("Failed to find group id {}"
                                    .format(self.starbase_client_group_id))
            group.authorize(ip_protocol='-1',
                            from_port='-1',
                            to_port='-1',
                            src_group=grp_lst[0])

    def update_instance_security_groups(self, node):
        """
        Adds the configured security groups to a node
        """
        groups = [str(g.id) for g in node.instance.groups] \
            + self.security_groups
        log.info("Updating {} security groups to {}"
                 .format(node.short_alias, groups))
        rez = node.ec2.conn.modify_instance_attribute(node.instance.id,
                                                      "groupSet",
                                                      groups)
        if not rez:
            log.error("Failed to assign additional security groups to {}"
                      .format(node.short_alias))
